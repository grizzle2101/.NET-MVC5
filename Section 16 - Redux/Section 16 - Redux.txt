---Section 16 - Redux---
---Tutorial 1 - Introduction---
In this section we're going to learn...
-What is Redux
-When to Use it & why?
-How to add redux to an existing app
-Redux DevTools
-Best practices for large enterprise apps


---Tutorial 2 - Redux---
So what is Redux?
Redux is a library that helps you manage the state of your application.

What is it used for?
It is used for Medium to Large sized Single Pages Applications with large & complex data flows.
It can add significant overhead, which is why we only use it in large applications. 

In the real world we might have several unrelated components & views that access the same
data. Because they are unrelated we are duplicating the data across each view/component.
Think of something like facebook, you might have a Bell Notification, messanger app
& the newsfeed. All of which need to pass data & keep each other in sync.

So to keep these unrelated components in sync, we have to do some extra work. Most often
people write events, but this can quicly spiral out of control into event spaghetti.
This can be a nightmare to track events in code, and leads to an unpredictable data flow and
difficult to manage states of the application.
This also makes developing new features hard, as we don't know the impact our change will
have on the overall state.

History:
Facebook has this problem back in 2014, which is why they created the Flux archtecture,
and Redux is a simpified & lightweight implmentation of flux, and provides a clean
& elegant solution to this problem.


Benefits:
So as well as helping us to manage state in a more predictable way, it has more benefits.
Lets recap some of those benefits.
-Predictable Application state

-Decoupled Architecutre:
    Decouples application from presentation framework like Angular,
    so you can implment a big chunk of your application & its presentation logic,
    which also allows us to choose any presentation framework like Angular or even React.
    Much like the repository pattern decoupling us from a specific ORM.

-Testability:
    We Implment Redux by utilizing simple functional programming, where we take
    a state, perform an action & return a new state.
    This is very easy to test, and means we don't have to work with complex
    Mocks or Stubs. We can implment TDD, as we write the redux first, before implmenting
    production code in Angular or Redux.

-Great Tooling:
    Redux Developer tools extension for Chrome or Firefox makes it very easy to debug
    the application state in such a way you have never seen before.

-Undo/Redo:
    Redux makes it incredibly easy to implment features like Undo & Redo.

Cons:
Just like all design patterns, we're going to write more code &  have more moving parts
in your application. So only use redux if you're going to a medium/large sized application
with complex views & data flows.


When to Use Redux:
Every scenario will of course be different, but in general we have some guidelines.

-Independent copies of the same data, in multiple places.
-Multiple Views that need to work with the same data & be in sync.
-Data can be updated by multiple Actors, eg multiple users, background actions or
 background tasks on the server.

 In the next section we're going to go over the various building blocks of Redux.


---Tutorial 3 - Building Blocks of Redux---
In Redux we have 3 pieces
-Store
-Actions
-Reducers

-Stores:-
The Store is a single JavaScript Objects that contains the state of the application.
Think of it like a local client-side database.

In practice it looks like a simple object with all the data we need for our views.
Different parts of the application use different parts of the Store, depending
on their functionality. Similar to a singleton, only 1 store object exists
to serve the various components.
{
    messages: [...],
    newMessages: 5,
    chatSoundsEnabled: true
}

-Actions:-
Actions are plain JavaScript objects that represent something that has happend.
If you have some background in CQRS style, you should know the difference between commands
and events.
Commands or Actions represent something that should happen like Posting a message.
Events indicated something that HAS happend, like a message was posted.
Actions in Redux are symantically like events, here is an example.

When a user reads a message, we can represent this with an action like this.
{type: 'MARK_AS_READ'}

Another example is if a user posts a message, we can raise an event of type POST_MESSAGE
then attach additional properties as needed.
These are just simple objects that represent the data being transferred.
Note "TYPE" is a convention we should follow.
{type: 'POST_MESSAGE', body:'...' }


Reducer:
A function that specifies how the state changes in response to an action.
We can think of this like an Action Handler or EventHandler, that determines
how the state is changed.
Note a Reducer does not modify the state, it ONLY returns a new state.

Not Allowed:
Nowhere in the application are we going to directly modify the state,
this is responsability of the store.
State.messages.push(...)


Take Home:
Stores are like a local database of the current application state. 
Actions are really events, used to pass data or state.
Reducers are Event Handlers that return a new state to the Store.
These are the building blocks of Redux, which we will go into more detail in the coming
lectures.


---Tutorial 4 - Pure Functions---
So what are pure functions? In a nutshell pure functions given the same input, give the same output
and there are no side effects.
-Same Input, Same output
-No Side Effects

Impure Functions:
So there are a few types of Impure arguements, lets go through examples of each.

Version 1 - Mutating Arguments:
--------------------------------
Lets take a function like this, we incremnt the given number. This is an example of an IMPURE function,
as it will ALWAYS give us a different result.

functions increment(input) {
    input.count ++;
}

Version 2 - Making Backend Calls
--------------------------------
So in this example we take the input & pass to the backend via a service, this modifies the state
of our application this is a clear side effect, and so is impure.

function incremtn(input){
    service.AddMessage(input)
}

Version 3 - Using an Impure Function
--------------------------------
This time we set counter to Math.Random, the problem with this is clear. Given the same input,
we cannot get the same output. So if we use Random or DateTime.Now, these are IMPURE!

function incremtn(input){
    input.cunter = Math.Random()
}


Pure Functions:
So taken the previous examples, lets take a look on how to refactor them into pure functions.

We by returning the count as input + 1, we are no longer modifying our own arguments, so its pure!
function increment(input) {
    return{count: input.count + 1}
}


Redux Pure Functions:
So in Redux, our reducers should be pure functions like the above example.
A reducer will have the current state and a action, then based on the action type
they return a new state.

So often a reducer will have a switch block for each action type, then have a pure function
to return the new state.

function reducer(state, action){
    switch(action.type){
        case 'INCREMENT':
            return{count: input.count + 1};
    }
}


This design may seem a bit weird, especially if you are new to functional programming.
Why do we not mutate or modify the state? why return a new one each time.
This method has some key benefits...
-testability (no mocks or spies)
    We don't need any of the complex mocks or spies, just input a value and assert the output!
-easy undo/redo
    This pattern allows for us to easily save the previous state and undo it, handy to have!

-Time Travel Debugging
    In the earlier lecture we mentioned some really cool debugging tools, trust me
    being able to travel back across the various states is very cool!

Just remember these are advanced features, just make sure your application warrants this!
So if it has data shared in many views, or has a complex data flow & syncing thats 
when these benefits really come into play!


---Tutorial 5 - Installing Redux---
So lets get going with Installing Redux in our application.
There are many implmentations of Redux but the 2 most common are
-ngrx/store
-ng2-redux

The difference being ngrx is the official version, but was just rewritten so is 
not entirely compatible with other libraries. This is why we are going with ng2.

Task 1 - Setup Project:
-npm install angular-cli -g
-mkdir redux-demo
-cd redux-demo
-ng init

-Make sure the version of Angular in package.json is like so.
    "@angular/common": "^2.3.1",


Task 2 - Install Redux:
-npm install redux ng2-redux --save
-ng serve to make sure this all works!


Task 3 Getting Started with Redux:
-Create a file store.ts
-Create our first Store called App State, we will add more properties to this store
as time goes on.

export interface IAppState {

}

-Create our first reducer
Remember every reducer takes in a State & Action, then contains case switch statements
for each action type, then returns the correct state. For now though, return state.

export function rootReducer(state, action)
{
    return state;
}

Task 4 - Setup & Imports:
So now that we have the basics in place, lets get Redux setup.

-Import Redux, and our implmentation of State & Reducers.
import {NgRedux, NgReduxModule} from 'ng2-redux';
import {IAppState, rootReducer} from './store'


-Bootstrap AppModule
Using the constructor we can take in an NgRedux object with the AppState we created.
Then call .configureStore & pass the reducer and a empty object as a place holder for
the initial store.

export class AppModule { 
  constructor(ngRedux: NgRedux<IAppState>){
    ngRedux.configureStore(rootReducer, {});
  }

Check localhost & console to make sure there are no errors.
Should definitly expect more errors in the coming sections, as both redux & Angular
have changed since the time of this recording.