---Section 16 - Redux---
---Tutorial 1 - Introduction---
In this section we're going to learn...
-What is Redux
-When to Use it & why?
-How to add redux to an existing app
-Redux DevTools
-Best practices for large enterprise apps


---Tutorial 2 - Redux---
So what is Redux?
Redux is a library that helps you manage the state of your application.

What is it used for?
It is used for Medium to Large sized Single Pages Applications with large & complex data flows.
It can add significant overhead, which is why we only use it in large applications. 

In the real world we might have several unrelated components & views that access the same
data. Because they are unrelated we are duplicating the data across each view/component.
Think of something like facebook, you might have a Bell Notification, messanger app
& the newsfeed. All of which need to pass data & keep each other in sync.

So to keep these unrelated components in sync, we have to do some extra work. Most often
people write events, but this can quicly spiral out of control into event spaghetti.
This can be a nightmare to track events in code, and leads to an unpredictable data flow and
difficult to manage states of the application.
This also makes developing new features hard, as we don't know the impact our change will
have on the overall state.

History:
Facebook has this problem back in 2014, which is why they created the Flux archtecture,
and Redux is a simpified & lightweight implmentation of flux, and provides a clean
& elegant solution to this problem.


Benefits:
So as well as helping us to manage state in a more predictable way, it has more benefits.
Lets recap some of those benefits.
-Predictable Application state

-Decoupled Architecutre:
    Decouples application from presentation framework like Angular,
    so you can implment a big chunk of your application & its presentation logic,
    which also allows us to choose any presentation framework like Angular or even React.
    Much like the repository pattern decoupling us from a specific ORM.

-Testability:
    We Implment Redux by utilizing simple functional programming, where we take
    a state, perform an action & return a new state.
    This is very easy to test, and means we don't have to work with complex
    Mocks or Stubs. We can implment TDD, as we write the redux first, before implmenting
    production code in Angular or Redux.

-Great Tooling:
    Redux Developer tools extension for Chrome or Firefox makes it very easy to debug
    the application state in such a way you have never seen before.

-Undo/Redo:
    Redux makes it incredibly easy to implment features like Undo & Redo.

Cons:
Just like all design patterns, we're going to write more code &  have more moving parts
in your application. So only use redux if you're going to a medium/large sized application
with complex views & data flows.


When to Use Redux:
Every scenario will of course be different, but in general we have some guidelines.

-Independent copies of the same data, in multiple places.
-Multiple Views that need to work with the same data & be in sync.
-Data can be updated by multiple Actors, eg multiple users, background actions or
 background tasks on the server.

 In the next section we're going to go over the various building blocks of Redux.


---Tutorial 3 - Building Blocks of Redux---
In Redux we have 3 pieces
-Store
-Actions
-Reducers

-Stores:-
The Store is a single JavaScript Objects that contains the state of the application.
Think of it like a local client-side database.

In practice it looks like a simple object with all the data we need for our views.
Different parts of the application use different parts of the Store, depending
on their functionality. Similar to a singleton, only 1 store object exists
to serve the various components.
{
    messages: [...],
    newMessages: 5,
    chatSoundsEnabled: true
}

-Actions:-
Actions are plain JavaScript objects that represent something that has happend.
If you have some background in CQRS style, you should know the difference between commands
and events.
Commands or Actions represent something that should happen like Posting a message.
Events indicated something that HAS happend, like a message was posted.
Actions in Redux are symantically like events, here is an example.

When a user reads a message, we can represent this with an action like this.
{type: 'MARK_AS_READ'}

Another example is if a user posts a message, we can raise an event of type POST_MESSAGE
then attach additional properties as needed.
These are just simple objects that represent the data being transferred.
Note "TYPE" is a convention we should follow.
{type: 'POST_MESSAGE', body:'...' }


Reducer:
A function that specifies how the state changes in response to an action.
We can think of this like an Action Handler or EventHandler, that determines
how the state is changed.
Note a Reducer does not modify the state, it ONLY returns a new state.

Not Allowed:
Nowhere in the application are we going to directly modify the state,
this is responsability of the store.
State.messages.push(...)


Take Home:
Stores are like a local database of the current application state. 
Actions are really events, used to pass data or state.
Reducers are Event Handlers that return a new state to the Store.
These are the building blocks of Redux, which we will go into more detail in the coming
lectures.


---Tutorial 4 - Pure Functions---
So what are pure functions? In a nutshell pure functions given the same input, give the same output
and there are no side effects.
-Same Input, Same output
-No Side Effects

Impure Functions:
So there are a few types of Impure arguements, lets go through examples of each.

Version 1 - Mutating Arguments:
--------------------------------
Lets take a function like this, we incremnt the given number. This is an example of an IMPURE function,
as it will ALWAYS give us a different result.

functions increment(input) {
    input.count ++;
}

Version 2 - Making Backend Calls
--------------------------------
So in this example we take the input & pass to the backend via a service, this modifies the state
of our application this is a clear side effect, and so is impure.

function incremtn(input){
    service.AddMessage(input)
}

Version 3 - Using an Impure Function
--------------------------------
This time we set counter to Math.Random, the problem with this is clear. Given the same input,
we cannot get the same output. So if we use Random or DateTime.Now, these are IMPURE!

function incremtn(input){
    input.cunter = Math.Random()
}


Pure Functions:
So taken the previous examples, lets take a look on how to refactor them into pure functions.

We by returning the count as input + 1, we are no longer modifying our own arguments, so its pure!
function increment(input) {
    return{count: input.count + 1}
}


Redux Pure Functions:
So in Redux, our reducers should be pure functions like the above example.
A reducer will have the current state and a action, then based on the action type
they return a new state.

So often a reducer will have a switch block for each action type, then have a pure function
to return the new state.

function reducer(state, action){
    switch(action.type){
        case 'INCREMENT':
            return{count: input.count + 1};
    }
}


This design may seem a bit weird, especially if you are new to functional programming.
Why do we not mutate or modify the state? why return a new one each time.
This method has some key benefits...
-testability (no mocks or spies)
    We don't need any of the complex mocks or spies, just input a value and assert the output!
-easy undo/redo
    This pattern allows for us to easily save the previous state and undo it, handy to have!

-Time Travel Debugging
    In the earlier lecture we mentioned some really cool debugging tools, trust me
    being able to travel back across the various states is very cool!

Just remember these are advanced features, just make sure your application warrants this!
So if it has data shared in many views, or has a complex data flow & syncing thats 
when these benefits really come into play!


---Tutorial 5 - Installing Redux---
So lets get going with Installing Redux in our application.
There are many implmentations of Redux but the 2 most common are
-ngrx/store
-ng2-redux

The difference being ngrx is the official version, but was just rewritten so is 
not entirely compatible with other libraries. This is why we are going with ng2.

Task 1 - Setup Project:
-npm install angular-cli -g
-mkdir redux-demo
-cd redux-demo
-ng init

-Make sure the version of Angular in package.json is like so.
    "@angular/common": "^2.3.1",


Task 2 - Install Redux:
-npm install redux ng2-redux --save
-ng serve to make sure this all works!


Task 3 Getting Started with Redux:
-Create a file store.ts
-Create our first Store called App State, we will add more properties to this store
as time goes on.

export interface IAppState {

}

-Create our first reducer
Remember every reducer takes in a State & Action, then contains case switch statements
for each action type, then returns the correct state. For now though, return state.

export function rootReducer(state, action)
{
    return state;
}

Task 4 - Setup & Imports:
So now that we have the basics in place, lets get Redux setup.

-Import Redux, and our implmentation of State & Reducers.
import {NgRedux, NgReduxModule} from 'ng2-redux';
import {IAppState, rootReducer} from './store'


-Bootstrap AppModule
Using the constructor we can take in an NgRedux object with the AppState we created.
Then call .configureStore & pass the reducer and a empty object as a place holder for
the initial store.

export class AppModule { 
  constructor(ngRedux: NgRedux<IAppState>){
    ngRedux.configureStore(rootReducer, {});
  }

Check localhost & console to make sure there are no errors.
Should definitly expect more errors in the coming sections, as both redux & Angular
have changed since the time of this recording.


---Tutorial 6 - Working with Actions---
So lets get started by creating a really simple component, that increments
and displays the number.


Task 1 - Create Button:
<p>Counter: {{counter}}</p>
<button (click)="increment()">Increment</button>


Task 2 - Add Logic in Component:
Now the logic for this would be veru simple, on click incrment counter.
However in the Redux architecture, we don't mutate variables, as it is impure!
We have to follow the redux architecture to implment this properly.

export class AppComponent {
  title = 'app works!';
  counter = 0;
  
  increment() {
    this.counter++;
  }
}

Task 3 - Implment Function the Redux Way:
So remember the Redux way, we dispatch an action to the store, the store knows
the rootReducer, the rootReducer will look at the action type, then return the
correct state to the store.

-Setup NgRedux:
So the first step in this process is importing NgRedux, creating the constructor
to access NgRedux, and provide the Store we implmented.

-Pass Action to State:
So now we have access to Store, we can pass the Action Object
{type: 'INCREMENT'}

export class AppComponent {
  constructor(private ngRedux: NgRedux<IAppState>){}
  
  increment() {
    this.ngRedux.dispatch({type: 'INCREMENT'});
  }
}


Task 4 - Adapt Reducer:
So we said reducers check the Action Type, then return the correct state.
To accomodate this, we just need to add a Case switch for 'INCREMENT'.

-Add Types to State & Return type for better clarity.
-Add Swtich & Case for INCREMENT action type.
-Use a Pure Function, remember we don't modify our state, we return a new one.

export function rootReducer(state: IAppState, action): IAppState{
    switch(action.type) {
        case 'INCREMENT': return {counter: state.counter + 1};
    }
    return state;
}

-Add Variables as needed, right now we need a Counter in our state.
export interface IAppState {
    counter: number;
}

Bug Fix:
So because we added a value to the AppState, when we pass our initial value in App.AppModule
we also have the pass the value here.

  constructor(ngRedux: NgRedux<IAppState>){
    ngRedux.configureStore(rootReducer, {counter: 0});
  }


Recap:
So lets go over what we did so far.
-Inject NgRedux in the contstuctor
-Instead of modifying the state directly, we called NgRedux.dispatch and passed an Action.

-Then we adapted our Reducer to Implment the 'INCREMENT' action.
-We also added the COUNTER value to our State, we can pass it between Action & reducer.
-Finally in App.Module we set the initial state of the Counter property.


Task 5 - Improvements:
So now that we understand what is done so far, lets improve on it.

-Magic Strings:-
This ActionType 'INCRMENT' we have this is 2 places, surely we can use a constant?
This will centralize our code & catch typo errors.

export const INCREMENT = 'INCREMENT';
We can then use this in Store.ts & app.component.


-Initial State:-
So every time we add a property to the IAppState, we also have to add the inital state
in app.module.

In the Store.ts, we can centralize this initial state & use it in App.Module.
export const INITIAL_STATE: IAppState = {
    counter: 0}


Note:
So Now we are dispatching an Action to Store, Store is selecting a reducer which returns
the right state to support our action type.
But what gives our counter is not working? That is because we have not done anything
with this new state, that is for our next lecture.


---Tutorial 7 - The Select Pattern:---
So now lets get going with reading the state.


Task 1 - Checkout NgRedux:
So if we look at NgRedux, we can subscribe to it, so its of type Observeable.
Lets log the state and see what happens.

  constructor(private ngRedux: NgRedux<IAppState>){
    ngRedux.subscribe(() => {
      console.log(ngRedux.getState());
    });
  }

Result:
After each click on Increment, we can see the State Object has counter & increments.
So this is exactly the behavior we expect.


Task 2 - Pass the State to View:
So now we know the state works, we have 2 ways to display this in our view.
We can store the value like so, and it works. However there are a few problems.
-LifeCycle hooks, we have to manage OnDesstory, else get memory leaks.
-Code Bloat, selecting items from the State.

  constructor(private ngRedux: NgRedux<IAppState>){
    ngRedux.subscribe(() => {
      var store = ngRedux.getState();
      this.counter = store.counter;
    });
  }


Task 3 - Use Select Module: (Aka Simple String select)
So with the problems raised from Task 2, the select Module should make our life easier.
So Select is a decorator or annotation, that selects a value from the state, and assigns it.
Expect this also handles the unsubscribe, and with much less bloat.
-import Select from Ng2-redux
-apply @select() annotation

export class AppComponent {
  title = 'app works!';
  @select('counter') count;



Task 4 - Working with Complex Objects:
Okay so that works fine with a simple object type, what about complex/nested types.

-Begin by adding Complex Object to state.
export interface IAppState {
    counter: number;
    messaging?: { //Messaging is Optional to avoid breaking everyting else.
        newMessages: number;
    }
}

//Exportable Initial State
export const INITIAL_STATE: IAppState = {
    counter: 0,
    messaging: {
        newMessages: 0
    }
}


Task 5 - Access a Complex Object:
Instead of a string we use am Array to provide a path to the target property.
So we have the messaging Object & new message inside.

-Select with Array
  @select(['messaging', 'newMessages']) newMessages;

-Select with Lambda Expression:
We can use an arrow function, IAppState properties & voila newMessages.
  @select((s: IAppState) => s.messaging.newMessages) myMessages;



Take Home:
In the previous lecture we passed an Action using ngRedux.dispatch, passing an initial state
& an ActionType. The Store recieves this and passed to reduced, which in turn
has a case switch for the ActionType INCREMENT, and returns a new incremented state.

In this section we are looking at ways to get the data from the State into the view.
We can subscribe to the ngRedux observeable, but that leads to bloat.
A better way is to use Select from ngRedux. This lets us apply annotations for

-Simple String Select:
@select('simpleStateProperty eg counter')

-Select w Array to Path:
@select(['complexObject', 'myProperty'])

-Select w Lambda:
@select((s: IAppStore) => s.complexObject.myProperty)