---Tutorial 1 - Introduction---
So in this section we're going to learn how to write automated tests for our Angular 2
apps. So if you're a beginer or expert, its helpful to go over this section.

What we'll cover in this section:
-Introduction to Automated testing
-Different Types of tests
-How to write tests
-Code Coverage 
-Practical Excercises


---Tutorial 2 - What is Automated Testing:---
Automated testing is the practice or writing code, to test our code, and writing
them in an automated fashion.

To effectively demonstrate this, lets create a scenario. We have a function that checks
for X or Y, then gives you the different result.

function Calculate(input) {
    if(x) retrn...;
    else if (y) return ...;
}

Manual Tests:
Using traditional manual tests, we have to build & deploy the applicaion then manually
fill out the form that uses this calculation.
This takes far too much time, and has to be repeated to catch regression bugs, and as
our application grows this quickly becomes unmangeable.

Automated Test:
We could write 2 test cases for the X & Y scenarios then voila, we don't have
all the headaches of deploying & manually testing, we can do it all from within out IDE.

//Test Case 1
var result = Calculate(x):
assert.That(result, expected)

//Test Case 2
var result = Calculate(y):

assert.That(result, expected)

The Opinionated Developer:
Why is it our Job to write tests? Why should we be writing Production code and
the Test code? Because mr joe blog, the cost of manual testing.

-To Document the Application:
As an application grows and shrinks, as does the team. The developers that built
these featues are long gone, and so too is any documentation on how it should work.
Do we just give up on these features? We need to maintain business value.

-Ballooning Regression:
As the application grows, so too does the effort & combinations required to test, this
can lead to a balooning workload for everyone in the team.
So to reduce the burden on manual testing & document the functionality it is nice to have
a suite of automated tests.

-Catch Bugs BEFORE Releasing:
Fairly self explanitory, lets catch bugs before building & deploying code.
The code you wrote works on your local, you go home for a beer but get a call from
the boss saying you broke some important functionality? Wouldn't it be nice
to have automated that...


Every scenario is different, some say a developer has to write tests for everything, some
say automated testing is useless so why bother.
Be pragmatic! If you are working on a budget, maybe tests are not the best use of your
time. However if you're working on a mission critical piece of functionality,
probabaly nice to have a few tests to cover your back!


---Tutotial 3 - Types of Tests---
So at a high level, there are 3 types of tests.
-Unit Tests
-Integration Tests
-End to End Tests


-Unit Tests:-
Tests a Component in Isolation, without any external resouces eg file system,
database, API Endpoints.
In Angular specifically that means testing a component, without its template or any
other resources.
So if our component uses a Service or Router, we're going to give it a fake instance
or Mock, do we test the component in isolation.

-Easiest to write
-Super Fast
-Don't give much confidence on entire application health

Example:
So we have a vote button that increments each time it is called.
The component has a single property & a single method.
export class VoteComponent {
    totalVotes: number;

    upVote() {
        this.totalVotes++;
    }
}

Template:
{{totalVotes}}
<button (click)="upVote()"> Up </button>


Testing in Isolation:
So to this test VoteComponent, we forget about the component altogther and just
check that upVote will increment the number correctly.
If there are wiring issues between the component & template, we don't catch those until
runtime, this is where Integration tests come into play.


-Integration Tests:-
Test a component with External resources eg FileSystem, database or API Endpoints.
Again this is the generic definition, in the Angular world this means we test
a component along with its template.
So taking the above example, we need to compile the application & write some setup
code to manage modules, dependency injection & so on. Again we get more confidence in
the application, but we still don't have the big picture of a full process, which is
where End to End tests come in.


-End to End Tests:-
End to End tests the entire application as a whole.
The entire end to end test might look something like we navigate to the application, login, click onto a particular page, fill out a form
then verify the results.
-More Confidence
-Very Slow
-Very Brittle
 A simple HTML change can break this application.


In Summary:
So we should focus our time on Unit & Integration tests, and use E2E tests to verify
key processes work, because they are fragile & slow.
-Unit Tests
-Integration Tests
-End to End Tests


---Tutorial 4 - Unit Testing Fundamentals---
Tests are first class citizens! This means we apply all the same principles we apply in everday
development.
Clean Coding practices like
-Small functions
-Proper Naming
-Single Responsability

We have includes a new project testing-demo, each section corresponds to a tutorial,
and will get increasingly difficult.
So to get this started use the following commands:
-npm install
-ng test
Builds the application & runs the built in test runner karma.


Our First Function:
In Computer.ts we have our first class to be tested.

export function compute(number) {
  if (number < 0)
    return 0; 

  return number + 1;
}


Task 1 - Create Test File:
Create a file in the 01 - fundamentals folder where computer.ts is located.
Make sure to follow the specific naming convention.
-compute.spec.ts
The Karma test runner looks for files with that extensions, and runs them accordingly.



Task 2 - Write a Test:
The test framework packaged with angular is Jasmine, this provides some nice methods
for Setting up and doing the AAA, Arrange, Act & Assert statements needed.
There are some language specifics that are new like
-describe() - A test Suit
-it() - Spec(A Test Case)

Describe takes 2 parameters, the name of the Item under test eg 'compute' function.
and a Pointer to a function for the test itself. eg the test code.
It() is a test case, so somethine like IsGreaterThanX, IsLessThanY, make sure
the name for the test is clear and explains its intention.
describe('compute', () => {
    it('test name', () => {
        
    })
})


Note:
Ran into a few problems with the testing-demo folder provided, needed to update the
package.json

  "devDependencies": {
    "@ngtools/webpack": "1.3.0",



Task 3 - Define the Tests:
So after looking at compute function we can see 2 possible outcomes, a negative number
and a positive number. So these are the first 2 cases we should write.

describe('compute', () => {
    it('Should return 0 if input is negative.', () => {
        const result = compute(-1);
        expect(result).toBe(0);
    })

    //Test Case 2:
    it('Should increment 1 if input is whole number.', () => {
        const result = compute(1);
        expect(result).toBe(2);
    })
})



Important Notes:
We use the Jasmine API to write the statements including how we assert things.
expect(result).toBe(0);

Expect has many more built in methods like IsLessThan, Is, Greater than etc, that we will
be using the upcoming tutorials.


---Tutorial 5 - Working with Strings & Arrays---
So this section is quite self explanitory, how to validate or Assert strings & arrays.


Test 1 - Strings:
In Example one we have a component that Greets, by taking the name as input then adds the name to the
greeting.

describe('greet', () => {
    it('Input is displayed in Message', () => {
        //Arrange

        //Act
        const result = greet('Ben');

        //Assert
        expect(result).toContain('Ben');
    })
})

Note:
Make sure to make these tests as robust as possible, by checking only for the existence of 'Ben'.
We don't want the test to fail if somone adds a comma or exclamation mark, its not important.

Test 2 - Arrays:
So in thie example we have a component which returns a list of currencies. Again we don't want to get
caught up in the ordering, incase we decide to do it alpabetically one day.

describe('getCurrencies', () => {
    it('Validate currencies are returned', () => {
        //Arrange

        //Act
        const result = getCurrencies();

        //Assert
        expect(result).toContain('USD');
        expect(result).toContain('AUD');
        expect(result).toContain('EUR');
    })
})



---Tutorial 6 - Setup & TearDown---
Okay from this point on we're going to be testing Angular components, so it will follow a certain
pattern/convention on how we work.
Take a look at section 3 voteComponent, we have a component which has  Upvote & Downvote methods, 
and modifies a internal value of voteCount. This is called the state change pattern.


Task 1 - Create Tests:
So testing the Upvote & Downvote functions are quite easy, but we have some duplicate code.
We should be be duplicating the Component creation, but we also have to make sure the value is setup
to avoid tests interfereing with each other...

describe('VoteComponent', () => {
  it('Should increment totalVotes when UpVoted', () => {
    //Arrange
    let component = new VoteComponent();

    //Act
    var result = component.upVote();
    
    //Assert
    expect(result).toBe(1);

  });

  it('Should decrement totalVotes when DownVoted', () => {
    //Arrange
    let component = new VoteComponent();

    //Act
    var result = component.downVote();
    
    //Assert
    expect(result).toBe(-1);

  });
});


Solution:
In C# & NUnit we had Setup to make sure to object creation is managed properly, and with Jasmine
we have the BeforeEach function.


Task 2 - Setup & Teardown:
So to solve this problem, we use beforeEach, this will create VoteComponent before each test.
We can then remove the Arrange part of each test, and the value of totalVotes is reset after
each test, so the tests don't interfere with each other.


describe('VoteComponent', () => {
  let component: VoteComponent;

  //Setup
  beforeEach(() => {
    component = new VoteComponent();
  });

  afterEach(() => {
  });
