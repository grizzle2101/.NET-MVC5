---Section 18 - Integration Testing---
---Tutorial 1 - Introduction:---
In the last section we learned how to unit test your Angular Components in isolation.
Unit tests are great for testing the logic of our components, but they have limitations
they cannot test the integration of a component with its template.
That is where Integration tests come into play.

In this section:
-Testing Templates
-Testing Navigation
-Testing Directives
-Dealing with Asynchronous operations.



---Tutorial 2 - The Setup Code---
So download the attached zip of the project to be tested & lets take a look at the setup.
As always to a npm install then ng build & test.


Note:
Had to remove the NavBarComponent as it is not included in solution for some reason.


Setting up Integration Test:
So for the component under test we normally new up the component in the beforeEach section.
Integration tests are a bit different, we need to let Angular create these components.

Task 1 - Setup TestBed:
So because we don't just create TypeScript Objects, instead we need angular compiled Objects
our setup is a little different.
Just like using NgModule, we have to setup the declarations.

import {TestBed, ComponentFixture} from '@angular/core/testing';

  beforeEach(() => {
    TestBed.configureTestingModule({
      declarations: [VoterComponent]
    });



Task 2 - Use TestBed:
So we now have access to the TestBed, we need to create a component & pass VoterComponent.
This is a wrapper on VoterComponent that gives us access to the compile time properties.
So the template and everything else, for real integration tests.

    TestBed.createComponent(VoterComponent);


Task 3 - Setup Component & Fixture:
Now that we have the TestBed setup, we can use them in our tests.

//Declare Variables
describe('VoterComponent', () => {
  let component: VoterComponent;
  let fixture: ComponentFixture<VoterComponent>;

  beforeEach(() => {
    TestBed.configureTestingModule({
      declarations: [VoterComponent]
    });
    //Set Values:
    fixture = TestBed.createComponent(VoterComponent);
    component = fixture.componentInstance;
  });


Additional Fixtures Elements:
So now that we have access to the Fixture, we can begin to see some of the cool features.

fixture.nativeElement - Returns Root DOM element for component eg the compiled HTML.
fixture.debugElement - Allows us to Debug the Native DOM.


Take Home:
ComponentFixture is a wrapper on a component, through this we can access the component
instance, the nativeElement(compiled HTML DOM) and debug it.
We can also do the change tracking manually(seeing objects added & removed), and even
get the injected dependencies in the component.
This will come very useful for writing integration tests. In the next section we'll look
at how to auto generate this test code.


---Tutorial 3 - Generating the Setup Code:---
Okay so now that we know what the setup code looks like, we can use Angular to generate
this for us.

Task 1 - Generate Boiler Plate Code:
ng generate component greeter


Result:
So we can see the auto generated code looks very similar to our code, but with a few
differences.
-2 beforeEach blocks
-Compile Components gets the HTML template, this file system read can take a while
which is why it is done Asynchronously, see async keyword & imports.

describe('GreeterComponent', () => {
  let component: GreeterComponent;
  let fixture: ComponentFixture<GreeterComponent>;

  //Configure Testing Mdoule
  beforeEach(async(() => {
    TestBed.configureTestingModule({
      declarations: [ GreeterComponent ]
    })
    .compileComponents(); //Compile Command gets the Components,
  }));

  //Create Component
  beforeEach(() => {
    fixture = TestBed.createComponent(GreeterComponent);
    component = fixture.componentInstance;
    fixture.detectChanges();
  });


Async Wrapper:
Async is a angular utility for running functions Asynchronously, create a function
and point it to a code block to run and it does all the heavy lifting.


Note:
Compile components is not neccessary is most applications as Webpack does this for us.
Webpack is the default builder for Angular, and will bundle the components natively,
so if you're using Webpack, its already done for us.



Task 2 - Combine beforeEach:
So because we using webpack, we can Combine both before blocks into one & now our
code looks very like the original...
So we can keep the complex setup, or simplify if needs be.

  beforeEach(() => {
    TestBed.configureTestingModule({
      declarations: [ GreeterComponent ]
    });

    fixture = TestBed.createComponent(GreeterComponent);
    component = fixture.componentInstance;
    fixture.detectChanges();
  });



---Tutorial 4 - Testing Property and Class Bindings---
So to get started writing our first intregration test, lets take a look at 1 - voter.
If we take a look at the voter component we will get a better idea of the things we 
should test.
-Class Bindings
-Property Bindings
-Style Bindings
-Event Bindings

Test 1 - Total Votes is Rendered Properly
Test 2 - If Upvoted, want to see the Style being applied
Test 3 - If I Upvote, should see the upvote method being called.


Test 1 - Total Votes is rendered properly:
So through the component, we can access the vote count & manipulate it.
To verify the value, we need to access the fixture & access to the root DOM element.
-Set otherVotes & myVote
-Query the fixture.debugElement for the Rendered Vote-Count CSS class.
-Because this is a Debug element(A wrapper on Native HTML/JavaScript) we need to 
 Access the HTML attribute to get the value.
-Expect the count to be 21.

  it('Should render total votes', () => {
    component.othersVote = 20;
    component.myVote = 1;

    let de = fixture.debugElement.query(By.css('.vote-count'))
    let el: HTMLElement = de.nativeElement;

    expect(el.innerText).toContain(21);
  });
});

Note:
We can use By.css or By.Directive if you have custom directives.
 fixture.debugElement.query(By.Directive(VoterComponent))



Test is Broken:
So we ran the test and appeared to get no value for VoteCount, what gives?
In the production envioronment Angular applies its change detection alghorithm, but
in this test mode it does not, so we have to manually turn that on.

fixture.detectChanges();


Test 2 - Pressing Vote Highlights Button:
So for the second test we just have to set myVote to 1, detect detectChanges
then ensure the highlighted style is applied.
-Check the rendered CSS class that should be applied eg .glyphicon-menu-up
-Access the debugElement for HTML properties for 'highlighted' and verify its true.

  it('Should Highlight the UpVote button if upvoted.', () => {
    component.myVote = 1;
    fixture.detectChanges();

    let de = fixture.debugElement.query(By.css('.glyphicon-menu-up'));

    expect(de.classes['highlighted']).toBeTruthy();
  });

Thats a wrap for the introduction to interaction tests, in the next tutorial we will
go over test 3, verifying when clicked it triggers the correct method.