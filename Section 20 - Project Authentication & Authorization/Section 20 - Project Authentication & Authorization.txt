---Section 20 - Project: Authentication & Authorization---
---Tutorial 1 - Introduction:---
In this section we're going to implment the login page, using Google OAuth.
We then need to store this information & show/hide the various routes/pages.


---Tutorial 2 - Implementing Google Login:---


Task 1 - Setup Authentication on Firebase:
So we have the Authentication Tab which has a section for Authentication providers,
Email password & Google.
-Enable Google Authentication


Task 2 - Add Login Link:
        <li class="nav-item">
          <a class="nav-link" routerLink="/login">Login</a>
        </li>


Task 3 - Setup Login Page:
-Add Button
<button
  (click)="login()"
  class="btn btn-primary">
  Login with Google
</button>


-Add OnClick Event:
At the time of recording firebase AngularFire has limited support for Authentication,
so in some cases we're going to work directly with firebase objects.
-Import all Firebase objects(will rework later)
-Take in AngularFireAuth via constructor
-Finally use Auth.signInWithRedirect and pass the Google provider.(will refactor this
design later, we should using dependency injection here.)

import * as firebase from 'firebase';
  constructor(private afAuth: AngularFireAuth) {}

  login()
  {
    this.afAuth.auth.signInWithRedirect(new firebase.auth.GoogleAuthProvider());
  }

Note:
firebase.auth contains many more providers we will support futher down the line.



---Tutorial 3 - Implementing the Logout:---
So now that Login is working, we need to Logout.

Task 1 - Rework HTML:
-Add OnClick Event to Logout.
      <a class="dropdown-item" (click)="logout()">Log Out</a>


Task 2 - Implment Logout in Component:

  logout() {
    this.afAuth.auth.signOut();
  }


Problem:
Although the method works, we get no response to know if it actually worked or not.
 

Solution:
We have the AuthState Observeable in AFAuth, we can subscrbe to this and display the 
current state to make sure we've logged out successfully.

  constructor(private afAuth: AngularFireAuth) { 
    afAuth.authState.subscribe( x => console.log("Status: ", x));
  }



---Tutorial 4 - Displaying the Current User:---
So now that we have data coming back from the firebase OAuth service, we can show/hide
and display the users details.


Task 1 - Add User Variable:
So we know from the last lecture we can subscrbe to the authState and get the user.
Lets assign that to a variable.

  user: firebase.User;

  constructor(private afAuth: AngularFireAuth) { 
    afAuth.authState.subscribe( user => this.user = user);
  }


Task 2 - Hide/Show Elements:
Now what we have acces the User details, we can show/hide elements.
-Show Login if we have not already logged in.
-Only show dropdown menu if logged in.
-Finally if logged in, use the displayName

        <li *ngIf="!user" class="nav-item">
          <a class="nav-link" routerLink="/login">Login</a>
        </li>
        <li ngbDropdown *ngIf="user" class="nav-item dropdown">
          <a ngbDropdownToggle class="nav-link dropdown-toggle" id="dropdown01" data-toggle="dropdown" aria-haspopup="true" aria-expanded="false">
            {{user.displayName}}
          </a>



---Tutorial 5 - Using the Asnc Pipe:---
So there is a problem with the current implmention of AuthService. We should ALWAYS
unsubscribe from an Observable.
We have 2 methods for going about this, we can implment onDestroy then unsubscribe.
OR the better option to use the Async Pipe.


Task 1 - Rework Component:
Set User to Observable, to use the Aysnc pipe we need to make the user$ an observable.
  user$: Observable<firebase.User>

  constructor(private afAuth: AngularFireAuth) { 
    this.user$ = afAuth.authState;
  }

Task 2 - Use Async Pipe:
Now that user$ is an Observable, we can set a template variable as the async value.
-If there is no value, we set it to anonymousUser which renders the Login tab.

         <!--Only Render Login if Anonymous User-->
        <ng-template #anonymousUser>
            <li class="nav-item">
              <a class="nav-link" routerLink="/login">Login</a>
            </li>
        </ng-template>

        <!--Get User Data Async-->
        <li ngbDropdown *ngIf="user$ | async as user; else anonymousUser" class="nav-item dropdown">
          <a ngbDropdownToggle class="nav-link dropdown-toggle" id="dropdown01" data-toggle="dropdown" aria-haspopup="true" aria-expanded="false">
            {{user.displayName}}
          </a>


---Tutorial 6 - Extracting a Service:---
So by now you've noticed the coupling in our NavBar Authentication, we should seperate the Authentication
into its own service. We would do this for 2 main reasons
-Testability
-Seperation of Concerns


The components themselves should not be responsible for Login & Logout, this should be a call to an
external service, that hides the implmentation from our components. Today we're using,
tomorrow we could be using soemthing else, lets encapsulate Authentication so we only have one place
to change this.


Task 1 - Generate a New Service:
ng g s auth



Task 2 - Add Reference in Providers:
Don't forget dependency injection.
  providers: [
    AuthService
  ],



Task 3 - Extract Service:
So we need to extract Login & Logout, then use this AuthService class in our components.

export class AuthService {
  constructor(private afAuth: AngularFireAuth) { }

  login() {
    this.afAuth.auth.signInWithRedirect(new firebase.auth.GoogleAuthProvider());
  }

  logout() {
    console.log("Logging Out...");
    this.afAuth.auth.signOut();
  }
}

Task 4 - Expose AuthState Observeable:
So in the NavBar constructor we use the AuthState to show/hide elements. We need to expose an Observeable
in our AuthService, so this functionality still works.
Variables used in Templates should be public. AOT compilation requires it.

  constructor(public afAuth: AngularFireAuth) {
        this.user$ = afAuth.authState;
  }

Note:
By Using Observable<firebase.user> we are leaking the implmentation detail to the outside world.
A seasoned programmer would say this is a bad practive, and we should be wrapping this to a public
friendly class like a DTO.


Last Step:
Finally now we've extracted the service, clean up all the unneccessary imports in NavBar & Login.



---Tutorial 7 - Protecting Routes:---
So we have a mix of pages, that require protection. Some should be viewable annoymously,
where as others need to be logged in as users, others as Admin.


Task 1 - Generate AuthGuard:
-Generate Service:
ng g s auth-guard

-Add Service into Providers:
  providers: [
    AuthService,
    AuthGuard
  ],


Task 2 - Implment AuthGuard:
-Get Authentication State
-Get Router
-Implement canActivate
-If we have User allow access, else redirect.

export class AuthGuard {
  constructor(private auth: AuthService, private router: Router) {}

  canActivate() {
    return this.auth.user$.subscribe(user => {
      if(user) return true;

      this.router.navigate(['/login']);
      return false;
    });
  }
}


Task 3 - Add AuthGuard to Route:
Now that we have the AuthGuard setup, we can add this to the various routes.
-Protect a route with property canActivate: [AuthGuard]

    RouterModule.forRoot([
      {path:'', component: HomeComponent},
      {path:'my/orders', component: MyOrdersComponent, canActivate: [AuthGuard]},
      {path:'products', component: ProductsComponent},
      {path:'shopping-cart', component: ShoppingCartComponent},
      {path:'check-out', component: CheckOutComponent, canActivate: [AuthGuard]},
      {path:'order-success', component: OrderSuccessComponent, canActivate: [AuthGuard]},
      {path:'login', component: LoginComponent},
      {path:'admin/products', component: AdminProductsComponent, canActivate: [AuthGuard]},
      {path:'admin/orders', component: AdminOrdersComponent, canActivate: [AuthGuard]},
  ])


In the next section we'll look at redirecting after a successful login. Later we will also
look at checking for various roles eg User & Admin.