---Section 23 - Project - Shopping Cart:---
---Tutorial 1 - Introduction:---
In this section we're going to focus on building the shopping cart functionality. We want to be
able to select products, see them get added to the shopping cart.
We can then click into our shopping cart, edit our orders and also see the calcualtions to get
the total price, all this happens in real time and even if you open a new tab we need to see
the data persisted. Lets get going!


---Tutorial 2 - Creating a Shopping Cart:---
In order to get started the first thing we need to look at it is creating a new shopping cart
the first time a user selects Add to Cart. This process should be available to anyone that
uses the application, do they not need to be logged in.


Features:
-Do NOT need to be logged in.
-Adding to Cart creates a Shopping Cart node in firebase.
-This Shopping cart node should have DateCreated & the Products selected by the user.
-We want to persist this shopping cart without a logged in User, storing Shopping Cart ID
in local storage.



Task 1 - Add to Cart:
So in the current implementation we have anchor tags to redirect a user, we don't want that.

 <div class="card-footer">
      <button *ngIf="showActions"
      (click)="addToCart(product)"
      class="btn btn-primary btn-block">Add to Cart</button>
    </div>


  addToCart(product: Product) {
    let cardId = localStorage.getItem('cartID');
    if(!cardId) {
      this.cartService.create().then(result => {
        localStorage.setItem('cartID', result.key);

        //Add Product to Cart:
      });
    }


Task 2 - Create Shopping Cart Service:
Now before we can proceed we need to create the Shopping Cart service.
-ng g s shopping-cart
-add in providers section app.module
-Create Service Logic

export class ShoppingCartService {

  constructor(private db: AngularFireDatabase) { }

  create() {
    return this.db.list('/shopping-carts').push({
      dateCreate: new Date().getTime()
    });
  }
}


Task 3 - Configure Firebase Permissions:
We get an exception when trying to create the shopping-card node, access denied.
Make sure to have READ & Write for shopping cart, or globally as I currently.


Result:
Now when clicking AddToCart we have a brand new shopping cart node in Firebase.


---Tutorial 3 - Refactoring - Moving Responsability to the Service:---
There is a problem with our Product Card component, it is taking on too many responsabilities.
From data access to setting local storage, this should all be extracted out.



Task 1 - Extract Cart Logic from Card:
Lets move this out from the Card Component and into the CartService.

let cardId = localStorage.getItem('cartID');
    if(!cardId) {
      this.cartService.create().then(result => {
        localStorage.setItem('cartID', result.key);

        //Add Product to Cart:
      });
    }
    else {
      //Add Product to Cart
    }


Task 2 - Refactor using Async:
Rather than using .then, have having all this code happen inside, we can make it look linear
with the Async & await methods.

  addToCart(product: Product) {
    let cardId = localStorage.getItem('cartID');
    if(!cardId) {
      this.cartService.create().then(result => {
        localStorage.setItem('cartID', result.key);

        //Add Product to Cart:
      });

Becomes:
    if(!cartID) {
      let result = await this.create();
      localStorage.setItem('cartID', result.key);
      return this.getCart(result.key);
    }


End Result:
We Internally manage the shopping carts, and in the next section we can carry on with Adding
products into the cart we retrieve internally.

  private async getOrCreateCart() {
    let cartID = localStorage.getItem('cartID');
    if(!cartID) {
      let result = await this.create();
      localStorage.setItem('cartID', result.key);
      return this.getCart(result.key);
    }
    return this.getCart(cartID);
  }


Usage:
Now in the Card, we just add to service, and let the service worry about the implementation.
  addToCart(product: Product) {
    this.cartService.addToCart(product);
  }
}


---Tutorial 4 - Adding a Product to the Shopping Cart:---
Okay so now we have the Shopping Cart components in place, lets work on adding items our shopping cart in firebase.


Task 1 - Refactor Cart Service:
-We don't need CART Object, just an ID will do.
-Check if Cart Exists first, cleaner code.

  private async getOrCreateCart() {
    let cartID = localStorage.getItem('cartID');
    if(cartID) return cartID;

    let result = await this.create();
    localStorage.setItem('cartID', result.key);
    return result.key;
  }


Task 2 -Implement AddToCart:
-Need to find a way to Update
  async addToCart(product: ProductNode) {
    let cartId = await this.getOrCreateCart();
    let cartItems = this.db.list('/shopping-carts/' + cartId + '/items/') as AngularFireList<ShoppingCartItem>;

    cartItems.update(product.key, {product: product.product, quantity: 1});
  }



Task 3 - Implment Add to Cart in Component:
  //Task 3 - Add Call to Service in Component:
  addToCart(product: ProductNode) {
    console.log('Adding to cart...')
    this.cartService.addToCart(product);
  }


Additional Work:
As the Methods Mosh used to Access the Quantity field and then update have been removed this might take a while to figure out.
Need to check If this product node exsits, if it does then Add + 1 to the Quantity.
Sounds simple, but for some reason is not. In the next lecure Mosh will be refacoting so fingers crossed that fixes it.

  //Additional Methods for Adding Existing Item, need to be able to Get & Updat
  async getQuantity(cartId: number, key: string) {
    let quantity;
    this.db.list('/shopping-carts/' + cartId + '/items/' + key).valueChanges()
    .subscribe(x => {
     console.log('Quantity:', x[1]);
    });
  }


  private async itemExists(cartId, key) {
    let item = this.db.list('/shopping-carts/' + cartId + '/items/');
    item.stateChanges().subscribe(i => {
      if(i.key == key) return true;
    });
    return false;
  }



---Tutorial 5 - Refactor AddToCart:---
So in this section we're just gonna do a some nice refactoring to make things a lot more readable.

Task 1 - Extract getCartItems:
we make several calls to DB LIST CART ID KEY,
we can extract this so AddToCart does not care about the implementation of finding a cart.


Task 2 - Simplify IF ELSE:
Why do 2 seperate calls IF then update ELSE then set.
We can use update in both cases, but make it smarter.

  cartItems.update(product.key, {product: product.product, quantity: (this.quantity || 0) + 1});
   


Task 3 - Test: 
Delete your cart, make sure it all works from scratch again.

Note:
Still some issues with the order in which it gets the quantity from DB and uses in the update statement.
Even though places inside an Await and a then method.



---Tutorial 6 - Displaying the Quantity:---
In this section we're going to work on displaying the quantity on a product card. On load we should retrive the shopping cart
and pass the cart as in input property of the card. We can then render & update the quantity on the card itself, much cooler!


Task 1 - Add Input to ProductCardComponent:
-Add ShoppingCart Input property to the ProductCardComponent.

export class ProductCardComponent {
  @Input('product') productNode: ProductNode;
  @Input('show-actions') showActions: boolean = true;
  @Input('shopping-cart') shoppingCart: ShoppingCart;



Task 2 - Add Quantity to Product Card:
-We want to hide the entire footer unless the user specifies.
-We don't want to add the logic for retrieving quantity in the template, as it makes it hard to unit test & messy.

    <div *ngIf="showActions" class="card-footer">
      <button 
      (click)="addToCart(productNode)"
      class="btn btn-primary btn-block">Add to Cart</button>
      <div>{{getQuantity()}}</div>
    </div>



Task 3 - Pass ShoppingCart:
-GET CARTITEMS:-
-Before we can pass the Cart, we need to expose a method from the service to get a Cart.
-The Service should be smart enough to figure out its own CartID, does not need input from consumer.

  async getCartItems() {
    let cartId = await this.getOrCreateCart();
    return this.db.list('/shopping-carts/' + cartId) as AngularFireList<ShoppingCartItem>;
  }

-INJECT CART SERVICE:-
-Use in ProductsComponent:
-Add into the Component:
  constructor(private route: ActivatedRoute, private productService: ProductService, private shoppingCartService: ShoppingCartService) {


-PRODUCT COMPONENT, PASS TO CARD:--
-We need to await the result of the service, but the constructor cannot be ASYNC. A workaround however is using ngOnInit.
-We need to handle subscription, pass the values to this.cartItems, then implment onDestroy to unsubscribe.

  async ngOnInit() {
    this.subscription =  (await this.shoppingCartService.getCartItems()).valueChanges().subscribe(items => {
      console.log('FETCHED CARTIEMS:', items);
      this.cartItems = items;
    });
  }

  //-UnSubscribe
  ngOnDestroy() {
    this.subscription.unsubscribe();
  }

-PASS FROM TEMPLATE:
-Pass the Cart to ProductCardComponent:
Now we pass the value from the ProductComponent, into the product card.
    <product-card [product]="p" [shopping-cart]="cart"></product-card>



Task 4 - Calculate Quantity in Component:
-NullCheck, ensure value is 0 as firebase may take a while.
-Retrive ProductNode from ShoppingCart
-If exists return else 0.

  getQuantity() {
    if(!this.shoppingCart) return 0;
    
    let item = this.shoppingCart.items[this.productNode.key];
    return item ? item.quantity: 0;
  }


Task 5 - Test:
Delete your shopping cart and try again....
All good!



---Tutorial 7 - Improving the Card Footer:---
In this section we're going to clean up the Product Card, add some nice buttons to increase/decrease the products in our cart.


Task 1 - CleanUp Card:
-Display Template UpdateQuantity if Quantity = 0.
-Add Button Toggle in Template
-Fix Styling issues
  -no-gutter - removes bootstrap margins.
  -Text Align Center

<div *ngIf="showActions" class="card-footer">
      <button *ngIf="getQuantity() === 0; else updateQuantity"
      (click)="addToCart(productNode)"
      class="btn btn-secondary btn-block">Add to Cart</button>
      <ng-template #updateQuantity>
        <div class="row no-gutters">
          <div class="col-2">
            <button class="btn btn-secondary btn-block">-</button>
          </div>
          <div class="col text-center">{{getQuantity()}}
          </div>
          <div class="col-2">
              <button class="btn btn-secondary btn-block">+</button>
            </div>
        </div>
      </ng-template>
    </div>



---Tutorial 8 - Implementing the Change Quantity Button:---
Now in this section we will implment the logic behind adding & subtracting items from the cart.


Task 1 - Handle Add Product:
-Update Template
          <div class="col-2">
              <button (click)="addToCart()" class="btn btn-secondary btn-block">+</button>
          </div>

-Remove Product Parameter, why pass a product object, when we already have access to one.
  addToCart() {
    console.log('Adding to cart...')
    this.cartService.addToCart(this.productNode);
  }


Task 2 - Implement Remove Product:
-Add Method call in template
          <div class="col-2">
            <button (click)="removeFromCart()" class="btn btn-secondary btn-block">-</button>
          </div>

-Add Method in Component

  removeFromCart(){
    console.log('Removing from cart...')
    this.cartService.removeFromCart(this.productNode);
  }


Task 3 - Implement RemoveFromCart in Service:
  async removeFromCart(product: ProductNode) {
    let cartId = await this.getOrCreateCart();
    let cartItems = await this.getCartItems();

    this.getQuantity(cartId, product).then(x => {
      console.log('USING VALUE', this.quantity);
      cartItems.update(product.key, {product: product.product, quantity: (this.quantity || 0) - 1});
    });
    

Task 4 - Refactor - Extract Common Logic:
So it works, but we have duplicated the same logic for adding & removing. It would make sense to extract this into a private method.
-Extract Duplicate code to new method.
  async updateItemQuantity(product: ProductNode, change: number) {
    let cartId = await this.getOrCreateCart();
    let cartItems = await this.getCartItems();

    this.getQuantity(cartId, product).then(x => {
      console.log('USING VALUE', this.quantity);
      cartItems.update(product.key, {product: product.product, quantity: (this.quantity || 0) + change});
    });
  }

-Usage
  async removeFromCart(product: ProductNode) {
    console.log('REMOVING PRODUCT:', product.product.title);
    this.updateItemQuantity(product, -1);
  }

Task 5 - Minor Styling Issue:
Again I think this is an issue with bootstrap, but items in the footer are not clickable.
-We want to make all items in the footer clickable.

.card-footer button {
    cursor: pointer;
}


---Tutorial 9 - Displaying ShoppingCartItems in NavBar:---
So in this section we want to add a NavBar item for Shopping cart and the count of items.


Task 1 - Rework NarBar:
-Subscribe to the cart, add the item.quantity field to a local variable the template can use.
-Set the value to 0 on start of the subscription.
-Don't need to Unsubscribe, as only 1 navbar exists.


  async ngOnInit() {
    this.authService.appUser$.subscribe(x => {this.appUser = x});

    let cart = await this.shoppingCartService.getCartItems();
    cart.valueChanges().subscribe(cart => {
      this.shoppingCartItemCount = 0; //Every Time Values are changed, will update.
      cart.forEach(item => this.shoppingCartItemCount += item.quantity);
    });
  }


Task 2 - Render Count:
-Add the span class badge pill from bootstrap to display the Shopping Cart icon.
-Insert the value from the COMPONENT
 <a class="nav-link"
           routerLink="/shopping-cart">
            Shopping Cart
            <span class="badge badge-warning badge-pill">{{shoppingCartItemCount}}</span>
          </a>


Task 3 - Test:
Add some Items, remove some make sure the count adds up and we didn't break anything.



---Tutorial 10 - Refactoring: Creating a Rich Model:---
So with the Current implmentation of ProductCount, anywhere we want to get the total quantity, we have to duplicate this code.
Would be better to add this into a service, so it can be used in many places.

    let cart = await this.shoppingCartService.getCartItems();
    cart.valueChanges().subscribe(cart => {
      this.shoppingCartItemCount = 0;
      cart.forEach(item => {
        this.shoppingCartItemCount += item.quantity
      });

Information Expert Principal:
The Object that has the information about performing a task, should be responsible for performing that task.


Task 1 - Create Shopping Cart Object:
So in accordance with the Information expert principal, the Shopping cart would be the best person to calculate the totalQuantity.

export class ShoppingCart {
  items: ShoppingCartItem[];

  get totalItemsCount() {
    let count = 0;
    for(let productId in this.items) count += this.items[productId].quantity;
    return count;
  }


Task 2 - Refactor Component & Template:
-Expose the Cart Observeable in Component
  cart$: Observable<ShoppingCart>;

-Set Observable to value returned from Service.
this.cart$ = await this.shoppingCartService.getCart();

-Use Value in Template:
            <span class="badge badge-warning badge-pill" *ngIf="cart$ | async as cart">
              {{cart$.totalItemsCount}}
            </span>



Task 3 - Rework Service to Use Interface:
    async getCartItemsMapped() {
      let cartId = await this.getOrCreateCart();
      let weh =  this.db.list('/shopping-carts/' + cartId + '/items/') as AngularFireList<ShoppingCart>
      return weh.valueChanges()
      .pipe(map(items => items.map(item => new ShoppingCart(item.items))));
    }


Note:
Although I made some progress integrating Moshes changes, was some difficultly Mapping the Service to return a ShoppingCart object with the correct data inside.
-The Shopping Cart worked, but the products inside were undefined.
-Async Pipe does not work with AngularFireList.
So for the reasons listed have noted his improvements, but kept my code as is.