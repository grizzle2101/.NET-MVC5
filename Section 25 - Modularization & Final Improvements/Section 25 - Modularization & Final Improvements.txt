---Tutorial 25 - Modularization & Final Improvements:---
---Tutorial 1 - Introduction:---
In this final section we're going to clean up eveything and modularize it for extensability.
Learning how to strcuture your application is extremely important for building enterprise applications, both in terms on the code & folder hierarchy.


---Tutorial 2 - Modules:---
Modules are like Isles in a grocery story, if we want a tin of beans we know to go to the tinned food section. In Angular we have
modules which are classes that contain metadata properties for classes & dependencies consume this module.

@NgModule
declarations[] - Define Components, Types 7 Directives
providers[] - Register Services Dependency Injection
imports[] - Dependencies of this module(building blocks from other modules)
exports[] - Expose components to the outside

export class AppModule(){}



Task 1 - Adding a Module:
So we're going to break the various sections of the application into logical modules. That would include areas of the application we can group togther like...
-Admin Module
-Shopping Module
-Shared Module - Product Card (used in Shopping & Admin Module), Shopping Cart etc.

-Membership Module - For all Authentication & future Authentication methods.


Project Structure:
So in the next few tutorials we plan on arranging the application to look something like this.
/app
    /{module}
        /Components
        /Services
        /Models
        {module}.module.ts



---Tutorial 3 - Essential TypeScript Plugins:---
So we want to make some big changes to the application structure without breaking the application. There are some great plugins to help us with this, Move TS in particular.

Plugins:
MoveTS - Updates imports when we move files/folders
TypeScript Hero - Removes unused imports & organizes them alpabetically.


Task 1 - Update TypeScipt Compiler:
So in our imports we have these nasty imports ./../../Products. We can provide an alias for this path so our imports look more like shared/products.
To do this we need to edit our tsconfig.json we add the base url for the project, then a set of paths.
shared* is a pattern, which we redirect to app/shared/* + whatever resources the user requests.

{
  "compileOnSave": false,
  "compilerOptions": {
    "baseUrl": "./",
    //"baseUrl": "./src",
    "paths": {
      "shared/*" : [
        "app/shared/*"
      ]
    },
    "outDir": "./dist/out-tsc",
    "sourceMap": true,
    "declaration": false,
    "module": "es2015",
    "moduleResolution": "node",
    "emitDecoratorMetadata": true,
    "experimentalDecorators": true,
    "target": "es5",
    "typeRoots": [
      "node_modules/@types"
    ],
    "lib": [
      "es2017",
      "dom"
    ]
  }
}



---Tutorial 4 - Moving Files & Folders:---
So now that we have the Alias setup & the plugins installed lets start moving some files & folders into modules.


Task 1 - Move Models:
app/shared


Task 2 - Move Service:
app/shared/services


Task 3 - Move a Component:
app/shared/components
product-Card
product quantity

Pause the video to move everything listed into the shared module folder.

Result:
So now that we've restructured the files & folders we can move onto creating modules. Because Angular still only knows off the app.module.


---Tutorial 5 - Creating a Shared Module:---
So that the files & folders are in place, we can remove all the shared components from app.module.

Task 1 - Create Shared Module:
-ng g m shared - Generated shared module class.


Task 2 - Flesh Out Module:
So just as we have in App.module, extract the componets into shared module.
@NgModule({
  declarations: [
    ProductCardComponent
  ],
  exports: [
    //Expose Components outside of Shared.
    ProductCardComponent
  ],
  imports: [
    CommonModule
  ],
  providers: [
    AuthService
  ]
})


Task 3 - Arrange Imports:
Using our new plugins we can tidy up the imports.
CTRL + ALT + o - Arranges Imports Alphabetically, components first then Services.


Task 4 - Inject Shared Modules:
-Clean up all the unused imports with CTL + ALT + o in app.module
-Import Shared Module



---Tutorial 6 - Creating the Admin Module:---
So just like with the shared module, we need to move everything into


Task 1 - Move Admin Files & Folders:
Structure:
app/admin
        /components
        /services

Items to be moved:
-admin folder
-auth guard



Task 2 - Create Admin Module:
-ng g m admin

@NgModule({
  declarations: [
    AdminProductsComponent,
    AdminOrdersComponent,
    ProductFormComponent
  ],
  exports: [],
  imports: [
    CommonModule,
    FormsModule, //Used in Product Form
    MaterialModule, //Used DataTable
    SharedModule, //Needed for ProductCard

    //For Child, declare routes for the Admin Module.
    RouterModule.forChild([
      { path: 'admin/products/new', component: ProductFormComponent, canActivate: [AuthGuard, AdminAuthGuard] },
      { path: 'admin/products/:id', component: ProductFormComponent, canActivate: [AuthGuard, AdminAuthGuard] },
      { path: 'admin/products', component: AdminProductsComponent, canActivate: [AuthGuard, AdminAuthGuard] },
      { path: 'admin/orders', component: AdminOrdersComponent, canActivate: [AuthGuard, AdminAuthGuard] }
    ])
  ],
  providers: [
    AuthGuard,
    AdminAuthGuard
  ]
})

export class AdminModule { }


Note:
Each Dependency will become apparent as you build, but FormsModule is a requirement and we also need to expose the product card from shared.
We do this by adding a reference in the export section of Shared and import the SharedModule.

-Modules let us encapsulate routes for a given module.

Task 3 - Import Admin Module & Cleanup:
So now that we've extracted everything into admin module, we can reduce the bloat in app.module.

  ],
  imports: [
    BrowserModule,
    SharedModule,
    AdminModule,
    FormsModule,