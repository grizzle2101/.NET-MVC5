----Section 7 - Template Driven Forms----
---Tutorial 1 - Inroduction---
In this section we're going to look at building forms with Angular.
-Implement Forms with different kinds of input fields.
-Display Validation Errors
-Disable Submit Button until form is valid.

---Tutorial 2 - Building a Basic Bootstrap Form---
We're just going to setup the form for this section, then iterate over it in each tutorial.
Forgot to install boostrap & add boostrap to style.css, but all sorted.

Task 1 - Build Really Simple BootStrap Form.


---Tutorial 3 - Types of Forms---
In Angular we have the concept of Form-Groups and Form-Controls. Form Group is a collection of Form Controls, and provides much of the same 
functionality like touched, valid, prestine etc allow us to validate the data in our form. Form-Group just allows us to apply this on every element,
where as Form Control is for a specific field.

In Angular there are 2 ways to achieve this, Directives & Code.

Template Driven forms:
We can apply some directives in our template, which allows Angular to build these Form Groups & Controls under the hood. 
We call these Template driven forms, where we generate the markup directly from the template.

Reactive/Model Driven Forms:
Explicity creating the control objects into our Markup or manually, is called Reactive forms or Model Driven Formns.

Whats the Difference?
Reactive:
-More Control over Validate Logic
-Good for Complex Forms
-Unit Testable

Template Driven:
-Good for Simple forms
-Simple Validation (required fields)
-Easier to Create
-Less Code


---Tutorial 4 - ngModel:---
So carrying on from our basic bootstrap form, we want to add validation with a template driven form.
So we need to use the ngModel directive, and allow angular to create a control object on our input fields.

Task 1 - Add ngModel to Form
Note that the Name field is required for Angular to create a control object.

Task 2 - Pass NgModel data to Log method.
If we bind to the Change event of our input, we can pass the NgModel and display it to get a better idea of whats happening under the hood.
(change)="log(firstName)"

Task 3 - Log the ngModel to Console
It Seems assigning ngModel to a template model does not wor anymore, NgModel not exportable anymore.
But the idea is not lost, we can pass the model and print out its data to get a better understanding.

Morale of the Story:
So we can pass the value of NgModel and see the various internal propeties NgModel uses to keep track of the data inside the Form-Control/Group.
We can use these values to dynamically validate our forms & data.

Problem:
With the Last Section could not bind NgModel to Template variable, this was because it was not added to App Module.these
import { FormsModule } from '@angular/forms'; Works now!

---Tutorial 5 - Adding Validation:---
Now that we know vaguely how NgModel works, we can begin to validate the data in our form.

Task 1 - Make FirstName field required.
Simply use the HTML attribute required.

Angular NgModel builds the Form control onto our firstName input, which also contains the requied value now.

Task 2 - Add Alert for Invalid Data.
Using a combination of NgIF & the data in NgModel, we can prompt the user to enter a Name!

---Tutorial 6 - Specific Validation---
Angular uses the built in HTML5 validtion properties, in this section we're going to go over a few of them.

Task 1 - Apply some Specific Validation attributes
minLength
maxLength
pattern - Makes sure the Input complies with a given Regex.
There are plenty more out there, so make sure to google them! or Explore the NgModel properties for a full list.


Task 2 - Create Seperate Validation Error for Each Rule
For each of the HTML error properties, we have NgModel.error, we can add an NgIF
for each of the possible errors, with its own custom error message.

Task 3 - Display the NgModel Errors in our Custom Errors:
Say the value of our MinLength may change at any time, and we want to make sure the message reflects the new value.
This can be done by directly accessing the error.minLength property.