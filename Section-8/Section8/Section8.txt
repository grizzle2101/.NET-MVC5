-----Section 8 - Reactive Forms-----
---Tutorial 1 - Introduction---
In the last section we learned about Template Driven Forms, now we're going to cover a different approach, reactive forms.
Rather than let angular create the form controls for us, we're going to explicitly create them, which gives us more control over the strcuture & behavior of the form.
When we create forms based on data returned from an API, reactive is are our best apporoach to dyanamically create the forms.
They also have the additional benefit of being Unit Testable. By the end of this section we should know how to...
-Create Controls Programatically
-Add Validation
-Implement Custom Validation
-Implment Asynchronous Validation(Usernames & Emails)
-Build Forms that include array of Objects that are added or removed dynamically.


---Tutorial 2 - Building a bootstrap form---
To speed things up, Mosh has included a zip file with the form component we are going to use for this section.
Added the signup-form, updated app.module.ts & added bootstrap.


---Tutorial 3 - Creating Controls Programatically---
So lets begin, we have the sign-up form which is now just a bootstrap form. To turn this into a Angular form, using the Template driven approach we would have 
applied NgModel to the input fields, Which angular would internally create an instance of the form control class and associated it with the input field.
However doing in the reactive way is a little different, we need to create these form control objects explicitly in the code.


Task 1 - Create Form Group
Task 2 - Insert Key Value Pairs
The Form Group object takes a Dictionary of Form Control Values, so for each input in the form, we need a key value pair here.

Task 3 - Bind out Form Object to HTML Form
Task 4 - Bind Input Field to Properties in our Class
Task 5 - Import Reactive Forms to AppModule

Morale of the Story:
Reactive VS Template Forms, with Reactive we Build the Component first, create a form group, with form controls representing each field in the form.
We then bind the Form Object to the HTML Form, then the KeyValue Pairs to the Inputs. We basically just do what angular does under the hood in template driven forms.
If representing complex objects, we can contain Form Groups, which also contain Form Controls. This allows us to create complex JSON.


---Tutorial 4 - Adding Validation ---
So if we remember template driven forms, we know that to add validation we used the built in HTML 5 validation attributes like Required, MinLength etc.
When using the reactive approach we don't use this anymore, we create custom validators to work on our form control objects.

Task 1 - Create a validator
So Import the Validator class from the Forms Module, and pass them to the FormControl objects we created earlier.

Parameters:
FormState is the Initial Value of the Input.(empty for us)
Validator, a build in Validator Class for Reactive forms.
username: new FormControl('', Validators.required),

Other Options:
Required
MinLength
MaxLength
pattern(regex)
email
Custom Validators(Will go over later.)
& More (make sure to explore options)

Task 2 - Create Validator Error Display Box.
Previously when doing template driven forms, we would store the NgModel in a template variable, then use this to check the validation state of various inputs.
With the reactive approach, we have to take another apporach.

Task 3 - Create Getter in Component
To simplify the front end, we can create a method to return the form control object, so don't have to consistently do this in the front end.

Task 4 - Refactor
So rather than accessing the form object multiple times, we can store it once in the component then use the username method instead.

Morale of the Story:
When creating a FormControl object to reference an input, we can also pass the built in Validator methods and voila we have validation!
We can also store these form control objects to make it easier to implment dynamic validation content like alerts.

---Tutorial 5 - Specific Validation Errors---
So keeping on the topic of validators, we also have the option of passing an array of validators.
This would allow us to apply multiple rules on a given input field.

Task 1 - Apply Multiple Validators
We can apply multiple validators, in the array.
username: new FormControl('', [Validators.required, Validators.minLength(3)])

Task 2 - Create Warnings for Different Errors.
Just like we did for the Template Driven forms, we can accomodate multiple error types inside the alert danger tab.
Expect insteado of the Template variable, holding the NgModel reference, we bind to the Exposer Username getter we created in a previous tutorial.

    <div *ngIf="username.touched && username.invalid" class="alert alert-danger">
        <div *ngIf="username.errors.required">UserName is Required!</div>
        <div *ngIf="username.errors.minlength">minLength {{username.errors.minlength.requiredLength}}</div>
    </div>


Morale of the Story:
Pass Arrays of Validators to the Function Control object, this is how have multiple rules on a single field.


---Tutorial 6 - Implmenting Custom Validation---
So far we have only looked at the built in validators, Required MinLength and so on. Its about time we create our own.
Looking at ValidatorFn function in the angular.io website, we can see the ValidationFn interface and signature we will have to follow.

Input                       Output
(C: AbstractControl) ValidationErrors | null
So in order for us to build a customer validator we're gonna have to follow this procedure.

Task 1 - Create a Validator Class
Make sure to follow the Convention for naming validator, username.validator.ts

Task 2 - Create Validator Method:
So after looking at the Angular IO we know the signature a Validator must follow. Take in a AbstractControl(the form control parent obj)
and return some ValidationErrors or null.

Task 3 - Return Validation Error
If we again look at Angular.io for ValidationErrors, we can see it is justa KeyValuePair of the key and value. They Key being the identifier for the method.
So if we were creating Required, it would be Required: true.
For the value, we can return more complex objects and error data.

Task 4 - Use Validator:
-Make sure to make the Validation Method, that way we don't have to instansiate them all over the place.
-Add Validator to Component UsernameValidators.cannotContainSpace
-Add Case to AlertBox.

Note:
For this tutorial we added the Validator directly into the signup-form compoment folder. If we're working on an Enterprise Application,
we should be all the validators into a common place to be used in various places in the application.
App > Common > Validators

Morale of the Story:
To Create a validator follow the signature for ValidationFn. This means taking in Abstract Control & returning validtion errors or null.
Validation Errors are simply the Key(methodName) and true, meaning it does contain space.
We can return more complex objects to help troubleshooting for the end user.


---Tutorial 7 - Async Operations---
There are times when validating our data needs to communicate with a server, like validating a Username dosen't already exist.
So lets start this my implmenting another validator for this.

Task 1 - Create New Validator
To keep things simple, as we have not yet covered how to make API calls, is just do a simple name check for 'Mosh'
A call to a server is an Asynchronous Operation, meaning non blocking or fire & forget. 

Asynchronous Examples:
-Calling the Server(AJAX)
-Set Timeout

Task 2 - Simulate Asynchronous Operation
So if we create a simple SetTimeout method, and move the logic for validating our data inside it.
We can we get errors. This is because my encapsulating our validation inside the Asynchronous action, we don't have any return type.
This is why in Angular, there is a new signature for us to use, something like a Async & Await in C#
We need to Await the result before performing & returning the validation, this will be covered more in the next section.

Morale of the Story:
Asynchronous Validations require a new ValidationFn type, which will be done in the next section.


---Tutorial 8 - Async Validators---
So as we dicussed in the previous tutorial, to make an Asychronous method, we need something with a different signature.
If we check Angular.io for AsyncValidatorFn, we can see it takes either a Promise<ValidationErrors> or Observerable<ValidationErrors> and
returns null, this is the new signature we need to follow.
We will go over the difference of a Promise & Over in a later section, but just know they are generally used with Asychronous actions.

Task 1 - Refactor shouldBeUnique with Asychronous Signature:
-Using the new signature as noted in the Angular.io site, Promise<ValidationErrors> | null
-The Parameters for a Promise Object is Resolve & Reject, which are methods.
-These Methods take in a optional value(or another Promise), and returns void.
-Basically we use Resolve as a Success & reject as the failure case.
-We can return complex error objects in the Reject to help troubleshooting


Task 2 - Add Asynchronous Validation to Form Control.
-The 3rd Optional Parameter for Form Control is for Asychronous validators. So make sure to close the Array of regular validators.

Task 3 - Create Error Div for shouldBeUnique.
-Same as before, just make sure to wait the 2 seconds(timeout).

Morale of the Story:
Asychronous Validators follow a Promise Object signature, which included a Promise of ValidationErrors or null.
This is how we can have a method with no return type, as we often won't until the action is complete.
We use resolve to notify the consumer/observer the action has finished, and reject to pass errors.

---Tutorial 9 - Showing a Loader Image---
When working with Async Validators, we might want to add a Loader Image, until the data we need is retrieved.
Angular makes this very easy.

Task 1 - Add Loading Text DIV
So we know username is a Form Control object in the Component, FormControl objects have this handy field called pending.
Pending will remail true as long as their is an Asynchronous action in the background.
So if we do an *ngIf on username.pending, we will get the temporary message we required.

Morale of the Story:
Use Form Control built in property Pending to check if an action is in progress.