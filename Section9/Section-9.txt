-----Section 9 - Consuming HTTP Services-----
---Tutorial 1 - Introduction---
So far we've looked at a lot of Angular Fundamentals, in this section we're going to look at consuming HTTP services.
By the end of this section, we're going to be able to connect our Components to the backend API's.
-Perform CRUD Operations(Create, Read, Update & Delete)
-Extrace a reuseable data services
-Properly Handle different kinds of Errors
-Building Applications with proper serperation of concerns.

This section is quite long, so make sure not to take breaks and follow along the code examples in each section.


---Tutorial 2 - JSON Placeholder---
So as we know Angular is a front end framework, we built it to use client applications. In most real world applications however we need a bunch of HTTP services
to get or save data. We are not going to be building backends in this section, but instead using http://jsonplaceholder.typicode.com/

---Tutorial 3 - Getting Data---
So lets try get some data from JSON Placeholder.

Task 1 - Import HttpModule to app.module.
By importing HttpModule, we're importing a list of HTTP Modules, and their dependencies as providers.


Task 2 - Create Constructor:
So in the Constructor, we take in HTTP, make a GET request then subscribe.
Remember when dealing with Asynchronous Validation, we said a Promise or Observeable is a command to tell the Thread to come back to this once we get data from the Endpoint.
Subscribe is an Observeable method, we subscribe to get notified when this GET has finished.

constructor(http: Http)
  {
    http.get("http://jsonplaceholder.typicode.com/posts")
    .subscribe(response => {
      console.log(response);
    });
  }

The Subscribe method has a few overloads, one of which allows us to take in a response and return void.
We can use this to manipulate data in the subscriber, so the response data from our GET.

Task 3 - Convert Response to JSON:
So we can see the Response, which contains lots of data like the Headers, MetaData & the actual posts.
So format this into something actually useable, we need response.json()

Task 4 - Render API Data in HTML:
Quite Straight forward, just need to Create a list, iterate over the posts using *ngFor, use string interpolation to inject post.title and bam we got a list of data.

Note:
When creating a new project, make sure to use the command - npm install bootstrap, then also make sure tue global style sheet is there.


---Tutorial 4 - Creating Data---
Let see how to take this to the next level, and create some posts.

Task 1 - Create an Input Field. 
-Create a Template Variable to Store Input #title then pass this to createPost method.


Task 2 - CreatePost Method in Component:
-Add the CreatePost method
-Http in our constructor, append private to make this a private variable in our component.
-Http.Post, takes 2 parameters the URL & JSON object to be posted.
-Every Http method in Angular has the subscribe method, this allows us to write the response to console.

Task 3 - Add Newly Created Item to List:
Because our API is a mock, it does not create the returned data like it should. Once given the Object, it should return it with a new ID, and additional details as
as needed. To Simulate this, we can use the response data, append this to our post Object, and throw it back to our Post List & voila!


---Tutorial 5 - Updating Data---
Next step, lets update some existing data!

Task 1 - Create Update Button for Each Post:
Create a simple button, bind the click event to CreatePost() and pass the post object.

Task 2 - Create CreatePost Method in Component:
We can use either POST or PATCH to send the updated Posts. In General though, PATCH is used when only sending part of object, like when ready an email you might only patch
the IsRead field, as opposed to send a entirely new post. so PUT is used to whole objects, PATCH is for partial data.

Post Usage:
this.http.post(this.url, JSON.stringify(post));

Patch Usage:
this.http.patch(this.url, JSON.stringify({isRead: true}));

Task 3 - Provide API ID:
We are getting errors when we kick off the Patch, that is because we do not have an ID for the post we wish to udpate.
By Adding the / and post.id we can now target the specific element we wish to update.
this.http.patch(this.url + '/' + post.id,JSON.stringify({isRead: true}))

Note:
If we check the Network Tab, find the PATCH call and check the request payload. We can see the payload is ONLY the isRead: true.
If we tried a PUT instead, we would see the entire object being sent.
Make sure to check an API supports PATCH before implementing something like this. This can however make our footprint much smaller,
and cut down on a lot of data & operations if we have complex objects.

---Tutorial 6 - Deleteing Data---

Task 1 - Add Delete Button
Same as before, just copy the update button and edit it to Delete & DeletePost method.

Task 2 - Implment DeletePost Method:
Very similar to the previoud CRUD methods, we just use the DELETE verb instead.
We only send the ID of the element we wish to delete, no object to be sent.
Once thats is complete, in the response, we find the index of our selected post, then splice it from our collection.
Voila we can now delete items from our list.


---Tutorial 7 - OnInit Interface---
So in the constructor we have our GET which loads the initial list of Posts for our application.
As a best practice, constructors should be very small and lightweight, we shouldn't perform expensive operations like Getting the posts.

When Should we GET this data?
Components in Angular have "LifeCycle Hooks", special methods that we add to our components then at a specific time Angular will call these methods at specific times.

LifeCycle Hooks:
-Creates a Component
-Renders It
-Creates & Renders its Children
-Destroys a Component

If we created components using the Angular CLI, we saw they automatically use OnInit, this is one such lifecycle hook.
So we have to implment OnInit, and complete the method defined there.

LifeCycle Hooks:
-OnInit
-OnChanges
-DoCheck
-AfterContentInit
...
Each of these LifeCycle hooks is a class, with a method of the same name prefixed with Ng. Eg NgOnInit, NgOnChanges etc.

Task 1 - Move Get Logic into NgOnInit:
So we just need to move the logic for getting posts into NgOnInit.

Morale of the Story:
If we want to NewUp objects or data, use NgOnInit instead of the constructor.
We also don't have to inherit from OnInit, just by having the NgOnInit method in our component, Angular will know. Its just by inheriting it we get compile time checking.


---Tutorial 8 - Seperation of Concerns:---
So the problem with our current implmentation is the Component takes on the responsibility for the API & manipulating the presentation layer.
This violated the Seperation of Concerns rule, where our classes should have a single responsibility.
There are several key benefits to refactoring, and moving our API to a Service including;
-Less Duplicate API code
-Changes to API are centralized
-More Unit Testable (not reliant on sevrver data, & can mock HTTP Service)
-Service is reuseable

In the next section we're going to extract the API responsibility to a service!